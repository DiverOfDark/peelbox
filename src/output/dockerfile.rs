use anyhow::Result;
use crate::output::schema::UniversalBuild;

/// Generates Dockerfiles from UniversalBuild specifications
pub struct DockerfileGenerator;

impl DockerfileGenerator {
    /// Generates a multi-stage Dockerfile from a UniversalBuild specification
    ///
    /// Creates a Dockerfile with:
    /// - Metadata comments (project info, confidence, reasoning)
    /// - Build stage with dependencies, environment, and build commands
    /// - Runtime stage with runtime dependencies and application setup
    /// - Proper handling of cache mounts and ports
    pub fn generate(build: &UniversalBuild) -> Result<String> {
        let mut dockerfile = String::new();

        // Add metadata header
        Self::add_header(&mut dockerfile, build);

        // Add build stage
        Self::add_build_stage(&mut dockerfile, build);

        // Add runtime stage
        Self::add_runtime_stage(&mut dockerfile, build);

        Ok(dockerfile)
    }

    fn add_header(df: &mut String, build: &UniversalBuild) {
        df.push_str("# Generated by aipack\n");

        if let Some(ref name) = build.metadata.project_name {
            df.push_str(&format!("# Project: {}\n", name));
        }

        df.push_str(&format!("# Language: {}\n", build.metadata.language));
        df.push_str(&format!("# Build system: {}\n", build.metadata.build_system));
        df.push_str(&format!("# Confidence: {:.0}%\n", build.metadata.confidence * 100.0));

        if !build.metadata.reasoning.is_empty() {
            df.push_str(&format!("# Reasoning: {}\n", build.metadata.reasoning));
        }

        df.push_str("\n");
    }

    fn add_build_stage(df: &mut String, build: &UniversalBuild) {
        df.push_str("# =============================================================================\n");
        df.push_str("# Build Stage\n");
        df.push_str("# =============================================================================\n");
        df.push_str(&format!("FROM {} AS builder\n\n", build.build.base));

        // Install build dependencies
        if !build.build.packages.is_empty() {
            df.push_str("# Install build dependencies\n");
            df.push_str("RUN apt-get update && \\\n");
            df.push_str("    apt-get install -y --no-install-recommends");
            for pkg in &build.build.packages {
                df.push_str(" \\\n        ");
                df.push_str(pkg);
            }
            df.push_str(" && \\\n");
            df.push_str("    rm -rf /var/lib/apt/lists/*\n\n");
        }

        // Set build environment variables
        if !build.build.env.is_empty() {
            df.push_str("# Set build environment variables\n");
            for (key, value) in &build.build.env {
                df.push_str(&format!("ENV {}={}\n", key, value));
            }
            df.push_str("\n");
        }

        // Infer working directory from first context entry
        let workdir = build.build.context
            .first()
            .map(|ctx| ctx.to.as_str())
            .unwrap_or("/app");

        if workdir != "." {
            df.push_str("# Set working directory\n");
            df.push_str(&format!("WORKDIR {}\n\n", workdir));
        }

        // Copy source code
        if !build.build.context.is_empty() {
            df.push_str("# Copy source code\n");
            for ctx in &build.build.context {
                df.push_str(&format!("COPY {} {}\n", ctx.from, ctx.to));
            }
            df.push_str("\n");
        }

        // Build commands with cache mounts
        if !build.build.commands.is_empty() {
            df.push_str("# Build application\n");

            if !build.build.cache.is_empty() {
                // Use cache mounts for build
                df.push_str("RUN");
                for cache_path in &build.build.cache {
                    df.push_str(&format!(" \\\n    --mount=type=cache,target={}", cache_path));
                }
                df.push_str(" \\\n    ");

                // Join all commands with &&
                for (i, cmd) in build.build.commands.iter().enumerate() {
                    if i > 0 {
                        df.push_str(" && \\\n    ");
                    }
                    df.push_str(cmd);
                }
                df.push_str("\n\n");
            } else {
                // No cache mounts
                for cmd in &build.build.commands {
                    df.push_str(&format!("RUN {}\n", cmd));
                }
                df.push_str("\n");
            }
        }
    }

    fn add_runtime_stage(df: &mut String, build: &UniversalBuild) {
        df.push_str("# =============================================================================\n");
        df.push_str("# Runtime Stage\n");
        df.push_str("# =============================================================================\n");
        df.push_str(&format!("FROM {}\n\n", build.runtime.base));

        // Install runtime dependencies
        if !build.runtime.packages.is_empty() {
            df.push_str("# Install runtime dependencies\n");
            df.push_str("RUN apt-get update && \\\n");
            df.push_str("    apt-get install -y --no-install-recommends");
            for pkg in &build.runtime.packages {
                df.push_str(" \\\n        ");
                df.push_str(pkg);
            }
            df.push_str(" && \\\n");
            df.push_str("    rm -rf /var/lib/apt/lists/*\n\n");
        }

        // Set runtime environment variables
        if !build.runtime.env.is_empty() {
            df.push_str("# Set runtime environment variables\n");
            for (key, value) in &build.runtime.env {
                df.push_str(&format!("ENV {}={}\n", key, value));
            }
            df.push_str("\n");
        }

        // Copy artifacts from builder
        if !build.runtime.copy.is_empty() {
            df.push_str("# Copy built artifacts from builder\n");
            for copy_spec in &build.runtime.copy {
                df.push_str(&format!(
                    "COPY --from=builder {} {}\n",
                    copy_spec.from, copy_spec.to
                ));
            }
            df.push_str("\n");
        }

        // Expose ports
        if !build.runtime.ports.is_empty() {
            df.push_str("# Expose application ports\n");
            df.push_str("EXPOSE");
            for port in &build.runtime.ports {
                df.push_str(&format!(" {}", port));
            }
            df.push_str("\n\n");
        }

        // Run application
        if !build.runtime.command.is_empty() {
            df.push_str("# Run application\n");
            df.push_str("CMD [");
            for (i, arg) in build.runtime.command.iter().enumerate() {
                if i > 0 {
                    df.push_str(", ");
                }
                df.push_str(&format!("\"{}\"", arg.replace('"', "\\\"")));
            }
            df.push_str("]\n");
        }
    }
}

impl UniversalBuild {
    /// Generates a Dockerfile from this UniversalBuild specification
    pub fn to_dockerfile(&self) -> Result<String> {
        DockerfileGenerator::generate(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::output::schema::{BuildMetadata, BuildStage, ContextSpec, CopySpec, RuntimeStage};
    use std::collections::HashMap;

    fn create_minimal_build() -> UniversalBuild {
        UniversalBuild {
            version: "1.0".to_string(),
            metadata: BuildMetadata {
                project_name: Some("test-app".to_string()),
                language: "Rust".to_string(),
                build_system: "cargo".to_string(),
                confidence: 0.95,
                reasoning: "Detected Cargo.toml".to_string(),
            },
            build: BuildStage {
                base: "rust:1.75".to_string(),
                packages: vec![],
                env: HashMap::new(),
                commands: vec!["cargo build --release".to_string()],
                context: vec![ContextSpec {
                    from: ".".to_string(),
                    to: "/app".to_string(),
                }],
                cache: vec![],
                artifacts: vec!["target/release/app".to_string()],
            },
            runtime: RuntimeStage {
                base: "debian:bookworm-slim".to_string(),
                packages: vec![],
                env: HashMap::new(),
                copy: vec![CopySpec {
                    from: "/app/target/release/app".to_string(),
                    to: "/usr/local/bin/app".to_string(),
                }],
                command: vec!["/usr/local/bin/app".to_string()],
                ports: vec![],
            },
        }
    }

    #[test]
    fn test_minimal_dockerfile() {
        let build = create_minimal_build();
        let dockerfile = DockerfileGenerator::generate(&build).unwrap();

        assert!(dockerfile.contains("FROM rust:1.75 AS builder"));
        assert!(dockerfile.contains("FROM debian:bookworm-slim"));
        assert!(dockerfile.contains("COPY . /app"));
        assert!(dockerfile.contains("RUN cargo build --release"));
        assert!(dockerfile.contains("COPY --from=builder /app/target/release/app /usr/local/bin/app"));
        assert!(dockerfile.contains("CMD [\"/usr/local/bin/app\"]"));
    }

    #[test]
    fn test_with_packages() {
        let mut build = create_minimal_build();
        build.build.packages = vec!["pkg-config".to_string(), "libssl-dev".to_string()];
        build.runtime.packages = vec!["ca-certificates".to_string()];

        let dockerfile = DockerfileGenerator::generate(&build).unwrap();

        assert!(dockerfile.contains("apt-get install -y --no-install-recommends"));
        assert!(dockerfile.contains("pkg-config"));
        assert!(dockerfile.contains("libssl-dev"));
        assert!(dockerfile.contains("ca-certificates"));
        assert!(dockerfile.contains("rm -rf /var/lib/apt/lists/*"));
    }

    #[test]
    fn test_with_env_vars() {
        let mut build = create_minimal_build();
        build.build.env.insert("CARGO_HOME".to_string(), "/cache/cargo".to_string());
        build.runtime.env.insert("PORT".to_string(), "8080".to_string());

        let dockerfile = DockerfileGenerator::generate(&build).unwrap();

        assert!(dockerfile.contains("ENV CARGO_HOME=/cache/cargo"));
        assert!(dockerfile.contains("ENV PORT=8080"));
    }

    #[test]
    fn test_with_cache_mounts() {
        let mut build = create_minimal_build();
        build.build.cache = vec!["/usr/local/cargo/registry".to_string()];

        let dockerfile = DockerfileGenerator::generate(&build).unwrap();

        assert!(dockerfile.contains("--mount=type=cache,target=/usr/local/cargo/registry"));
    }

    #[test]
    fn test_with_ports() {
        let mut build = create_minimal_build();
        build.runtime.ports = vec![8080, 8443];

        let dockerfile = DockerfileGenerator::generate(&build).unwrap();

        assert!(dockerfile.contains("EXPOSE 8080 8443"));
    }

    #[test]
    fn test_metadata_comments() {
        let build = create_minimal_build();
        let dockerfile = DockerfileGenerator::generate(&build).unwrap();

        assert!(dockerfile.contains("# Generated by aipack"));
        assert!(dockerfile.contains("# Project: test-app"));
        assert!(dockerfile.contains("# Language: Rust"));
        assert!(dockerfile.contains("# Build system: cargo"));
        assert!(dockerfile.contains("# Confidence: 95%"));
        assert!(dockerfile.contains("# Reasoning: Detected Cargo.toml"));
    }

    #[test]
    fn test_to_dockerfile_method() {
        let build = create_minimal_build();
        let dockerfile = build.to_dockerfile().unwrap();

        assert!(dockerfile.contains("FROM rust:1.75 AS builder"));
        assert!(dockerfile.contains("FROM debian:bookworm-slim"));
    }
}
