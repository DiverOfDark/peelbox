use aipack::cli::output::{OutputFormat, OutputFormatter};
use aipack::output::schema::{
    BuildMetadata, BuildStage, ContextSpec, CopySpec, RuntimeStage, UniversalBuild,
};
use std::collections::HashMap;

fn create_rust_build() -> UniversalBuild {
    let mut build_env = HashMap::new();
    build_env.insert("CARGO_HOME".to_string(), "/cache/cargo".to_string());

    let mut runtime_env = HashMap::new();
    runtime_env.insert("PORT".to_string(), "8080".to_string());

    UniversalBuild {
        version: "1.0".to_string(),
        metadata: BuildMetadata {
            project_name: Some("my-rust-app".to_string()),
            language: "Rust".to_string(),
            build_system: "cargo".to_string(),
            confidence: 0.95,
            reasoning: "Detected Cargo.toml with standard Rust project structure".to_string(),
        },
        build: BuildStage {
            base: "rust:1.75".to_string(),
            packages: vec!["pkg-config".to_string(), "libssl-dev".to_string()],
            env: build_env,
            commands: vec!["cargo build --release".to_string()],
            context: vec![ContextSpec {
                from: ".".to_string(),
                to: "/app".to_string(),
            }],
            cache: vec!["/usr/local/cargo/registry".to_string()],
            artifacts: vec!["target/release/my-rust-app".to_string()],
        },
        runtime: RuntimeStage {
            base: "debian:bookworm-slim".to_string(),
            packages: vec!["ca-certificates".to_string(), "curl".to_string()],
            env: runtime_env,
            copy: vec![CopySpec {
                from: "/app/target/release/my-rust-app".to_string(),
                to: "/usr/local/bin/my-rust-app".to_string(),
            }],
            command: vec!["/usr/local/bin/my-rust-app".to_string()],
            ports: vec![8080],
        },
    }
}

#[test]
fn test_dockerfile_generation_rust_project() {
    let build = create_rust_build();
    let formatter = OutputFormatter::new(OutputFormat::Dockerfile);

    let dockerfile = formatter.format(&build).unwrap();

    // Check header comments
    assert!(dockerfile.contains("# Generated by aipack"));
    assert!(dockerfile.contains("# Project: my-rust-app"));
    assert!(dockerfile.contains("# Language: Rust"));
    assert!(dockerfile.contains("# Build system: cargo"));
    assert!(dockerfile.contains("# Confidence: 95%"));

    // Check build stage
    assert!(dockerfile.contains("FROM rust:1.75 AS builder"));
    assert!(dockerfile.contains("pkg-config"));
    assert!(dockerfile.contains("libssl-dev"));
    assert!(dockerfile.contains("ENV CARGO_HOME=/cache/cargo"));
    assert!(dockerfile.contains("COPY . /app"));
    assert!(dockerfile.contains("cargo build --release"));
    assert!(dockerfile.contains("--mount=type=cache,target=/usr/local/cargo/registry"));

    // Check runtime stage
    assert!(dockerfile.contains("FROM debian:bookworm-slim"));
    assert!(dockerfile.contains("ca-certificates"));
    assert!(dockerfile.contains("curl"));
    assert!(dockerfile.contains("ENV PORT=8080"));
    assert!(dockerfile.contains("COPY --from=builder /app/target/release/my-rust-app"));
    assert!(dockerfile.contains("EXPOSE 8080"));
    assert!(dockerfile.contains("CMD [\"/usr/local/bin/my-rust-app\"]"));
}

#[test]
fn test_dockerfile_generation_minimal() {
    let build = UniversalBuild {
        version: "1.0".to_string(),
        metadata: BuildMetadata {
            project_name: Some("simple-app".to_string()),
            language: "Python".to_string(),
            build_system: "pip".to_string(),
            confidence: 0.8,
            reasoning: "Found requirements.txt".to_string(),
        },
        build: BuildStage {
            base: "python:3.11".to_string(),
            packages: vec![],
            env: HashMap::new(),
            commands: vec!["pip install -r requirements.txt".to_string()],
            context: vec![ContextSpec {
                from: ".".to_string(),
                to: "/app".to_string(),
            }],
            cache: vec![],
            artifacts: vec![],
        },
        runtime: RuntimeStage {
            base: "python:3.11-slim".to_string(),
            packages: vec![],
            env: HashMap::new(),
            copy: vec![CopySpec {
                from: "/app".to_string(),
                to: "/app".to_string(),
            }],
            command: vec!["python".to_string(), "app.py".to_string()],
            ports: vec![],
        },
    };

    let formatter = OutputFormatter::new(OutputFormat::Dockerfile);
    let dockerfile = formatter.format(&build).unwrap();

    assert!(dockerfile.contains("FROM python:3.11 AS builder"));
    assert!(dockerfile.contains("FROM python:3.11-slim"));
    assert!(dockerfile.contains("pip install -r requirements.txt"));
    assert!(dockerfile.contains("CMD [\"python\", \"app.py\"]"));
}

#[test]
fn test_dockerfile_without_healthcheck() {
    let build = UniversalBuild {
        version: "1.0".to_string(),
        metadata: BuildMetadata {
            project_name: None,
            language: "Node.js".to_string(),
            build_system: "npm".to_string(),
            confidence: 0.9,
            reasoning: "Found package.json".to_string(),
        },
        build: BuildStage {
            base: "node:18".to_string(),
            packages: vec![],
            env: HashMap::new(),
            commands: vec!["npm install".to_string(), "npm run build".to_string()],
            context: vec![ContextSpec {
                from: ".".to_string(),
                to: "/app".to_string(),
            }],
            cache: vec![],
            artifacts: vec!["dist/".to_string()],
        },
        runtime: RuntimeStage {
            base: "node:18-alpine".to_string(),
            packages: vec![],
            env: HashMap::new(),
            copy: vec![CopySpec {
                from: "/app/dist".to_string(),
                to: "/app/dist".to_string(),
            }],
            command: vec!["node".to_string(), "/app/dist/index.js".to_string()],
            ports: vec![3000],
        },
    };

    let formatter = OutputFormatter::new(OutputFormat::Dockerfile);
    let dockerfile = formatter.format(&build).unwrap();

    assert!(dockerfile.contains("npm install"));
    assert!(dockerfile.contains("npm run build"));
    assert!(dockerfile.contains("EXPOSE 3000"));
    assert!(!dockerfile.contains("HEALTHCHECK"));
}

#[test]
fn test_dockerfile_multiple_copy_specs() {
    let build = UniversalBuild {
        version: "1.0".to_string(),
        metadata: BuildMetadata {
            project_name: Some("multi-copy".to_string()),
            language: "Go".to_string(),
            build_system: "go".to_string(),
            confidence: 0.92,
            reasoning: "Found go.mod".to_string(),
        },
        build: BuildStage {
            base: "golang:1.21".to_string(),
            packages: vec![],
            env: HashMap::new(),
            commands: vec!["go build -o app".to_string()],
            context: vec![
                ContextSpec {
                    from: "go.mod".to_string(),
                    to: "/app/go.mod".to_string(),
                },
                ContextSpec {
                    from: "go.sum".to_string(),
                    to: "/app/go.sum".to_string(),
                },
                ContextSpec {
                    from: ".".to_string(),
                    to: "/app".to_string(),
                },
            ],
            cache: vec![],
            artifacts: vec!["app".to_string()],
        },
        runtime: RuntimeStage {
            base: "alpine:3.19".to_string(),
            packages: vec![],
            env: HashMap::new(),
            copy: vec![
                CopySpec {
                    from: "/app/app".to_string(),
                    to: "/usr/local/bin/app".to_string(),
                },
                CopySpec {
                    from: "/app/config".to_string(),
                    to: "/etc/app/config".to_string(),
                },
            ],
            command: vec!["/usr/local/bin/app".to_string()],
            ports: vec![],
        },
    };

    let formatter = OutputFormatter::new(OutputFormat::Dockerfile);
    let dockerfile = formatter.format(&build).unwrap();

    // Check multiple COPY instructions in build stage
    assert!(dockerfile.contains("COPY go.mod /app/go.mod"));
    assert!(dockerfile.contains("COPY go.sum /app/go.sum"));
    assert!(dockerfile.contains("COPY . /app"));

    // Check multiple COPY --from=builder instructions
    assert!(dockerfile.contains("COPY --from=builder /app/app /usr/local/bin/app"));
    assert!(dockerfile.contains("COPY --from=builder /app/config /etc/app/config"));
}
